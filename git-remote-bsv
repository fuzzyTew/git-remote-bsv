#!/usr/bin/env node

const child_process = require('child_process')
const crypto = require('crypto')
const glob = require('glob')
const path = require('path')
const readline = require('readline')
const fs = require('fs')

const bsv = require('bsv')
const rimraf = require('rimraf')

if (process.argv.length < 3) {
  process.stderr.write('\n')
  process.stderr.write('Here is a new url pair for you.  Remember to send coins to the pull address.\n')
  let key = bsv.PrivateKey()
  process.stderr.write('    push: bsv://' + key.toString() + '/path/to/repo.git\n')
  process.stderr.write('    pull: bsv://' + key.toAddress().toString() + '/path/to/repo.git\n')
  process.stderr.write('\n')
  process.exit(0);
}

const GIT_DIR = path.resolve(process.env.GIT_DIR)
const BSVUP = path.join(__dirname, 'node_modules', 'bsvup', 'cli.js')
var FETCH_SITE = (process.env.BSV_GATEWAY || 'https://bico.media').replace('://','::') // '::' instead of '://' informs git the server has no git cgi
if (FETCH_SITE.slice(-1) != '/') FETCH_SITE += '/'

const remotename = process.argv[3] ? process.argv[2] : undefined
const origurl = remotename ? process.argv[3] : process.argv[2]
var url = origurl
url = url.replace('bsv://','')
url = url.replace('https://','')
url = url.replace('http://','')
url = url.replace('bico.media/','')

const urlparts = url.split('/')
const subkey = urlparts.slice(1).join('/')
var addr = urlparts[0]
var privkey = undefined
if (bsv.PrivateKey.isValid(addr)) {
  privkey = addr
  addr = bsv.PrivateKey(privkey).toAddress().toString()
  urlparts[0] = addr
  url = urlparts.join('/')
  if (remotename) {
    if (child_process.spawnSync('git', ['config', '--get', 'remote.' + remotename + '.pushurl']).stdout.length == 0) {
      child_process.spawnSync('git', ['remote', 'set-url', '--push', remotename, origurl])
      child_process.spawnSync('git', ['remote', 'set-url', remotename, origurl.replace(privkey, addr)])
    }
  }
}

const hash = crypto.createHash('sha256')
const bsv_path = path.join(GIT_DIR, 'bsv', addr)
const fork_glob = path.join(GIT_DIR, 'bsv', '*', 'git.*')
const mirror_path = path.join(bsv_path, 'git.' + hash.update(urlparts.join(path.sep)).digest('hex'))
const mirror_path_new = path.join(bsv_path, 'git.new')

const lines = readline.createInterface({
  input: process.stdin
})

lines.on('line', (line) => {
  if (line === "capabilities") {
    process.stdout.write('connect\n\n')
  } else if (line.substr(0,8) === "connect ") {
    const service = line.substr(8)
    connect(service).catch(err => {
      process.stderr.write(err + '\n')
      process.exit(-1)
    })
  }
})

async function connect(service)
{
  if (service === 'git-upload-pack') {
    download()
  } else if (service === 'git-receive-pack') {
    if (!privkey) {
      process.stderr.write('Url not recognized as private key to upload to\n')
      process.exit(-1)
    }
    try {
      download()
    } catch(e) {
      if (! fs.existsSync(mirror_path)) {
        const res = child_process.spawnSync('git', ['init', '--bare', mirror_path], { stdio: [null,2,2], env: {} })
        if (res.status !== 0) process.exit(res.status)
        await new Promise((resolve, reject) => {
          glob(path.join(fork_glob, 'objects', 'pack', '*'), function (er, files) {
            if (er !== null) {
              sys.stderr.write(er + '\n')
              process.exit(-1)
            }
            for (let file of files) {
              try {
                fs.copyFileSync(file, path.join(mirror_path, 'objects', 'pack', path.basename(file)), fs.constants.COPYFILE_EXCL)
              } catch(e) {}
            }
            resolve()
          })
        })
      }
    }
  } else {
    process.stderr.write('Unsupported service: ' + service + '\n')
    process.exit(-1)
  }
  process.stdout.write('\n')
  const res = child_process.spawnSync(service, [mirror_path], { stdio: 'inherit', cwd: mirror_path })
  if (res.status !== 0) process.exit(res.status)
  if (service === 'git-receive-pack') {
    upload()
  }
}

function download()
{
  const fetchurl = FETCH_SITE + url
  var res
  if (! fs.existsSync(mirror_path))
  {
    fs.mkdirSync(mirror_path, {recursive: true})
    res = child_process.spawnSync('git', ['clone', '--bare', '--mirror', fetchurl, mirror_path], { cwd: mirror_path, stdio: [null,2,2], env: {GIT_DIR: mirror_path} })
  } else {
    res = child_process.spawnSync('git', ['fetch', '--tags', fetchurl, '+refs/*:refs/*'], { cwd: mirror_path, stdio: [null,2,2], env: {GIT_DIR: mirror_path} })
  }
  if (res.status !== 0) throw new Error("Failed to fetch")
}

async function upload()
{
  if (fs.existsSync(mirror_path_new)) {
    rimraf.sync(mirror_path_new)
  }
  child_process.spawnSync('git', ['clone', '--mirror', '--bare', mirror_path, mirror_path_new], {stdio:[null,2,2],env:{}})
  child_process.spawnSync('git', ['repack'], { cwd: mirror_path_new, stdio: [null,2,2], env: {GIT_DIR: mirror_path_new} })
  child_process.spawnSync('git', ['prune-packed'], { cwd: mirror_path_new, stdio: [null,2,2], env: {GIT_DIR: mirror_path_new} })
  const first_commit = child_process.spawnSync('git', ['rev-list', '--max-parents=0', 'HEAD'], { cwd: mirror_path_new, env: {GIT_DIR: mirror_path_new} }).stdout.toString().replace('\n','')
  child_process.spawnSync('git', ['tag', url.replace(':','/').replace(/\/\/*/, '/'), first_commit], { cwd: mirror_path_new, env: {GIT_DIR: mirror_path_new} })
  child_process.spawnSync('git', ['update-server-info'], { cwd: mirror_path_new, stdio: [null,2,2], env: {GIT_DIR: mirror_path_new} })
  fs.writeFileSync(path.join(mirror_path_new, 'git-remote-bsv'), 'This is a git-remote-bsv D:// web repository.')
  if (! fs.existsSync( path.join(bsv_path, '.bsv', 'key') ) ) {
    let bsvupaddr;
    let bsvup = child_process.execFile(BSVUP, ['-p', 'Y', 'init'], { cwd: bsv_path })
    bsvup.stdin.write(privkey + '\n')
    bsvupaddr = await new Promise((resolve, reject) => {
      const rl = readline.createInterface({input: bsvup.stdout})
      let foundaddr = undefined
      rl.on('line', (line) => {
        let m = line.match('onchain addressï¼š\(.*\)')
        if (m) {
          process.stderr.write(line + '\n')
          foundaddr = m[1]
          rl.close()
        }
      })
      rl.on('close', () => { if (foundaddr) resolve(foundaddr); else reject('bsvup did not give addr'); })
    })
    await new Promise((resolve, reject) => {
      bsvup.on('error', reject)
      bsvup.on('exit', resolve)
      bsvup.stdout.pipe(process.stderr)
    })
    if (bsvupaddr !== addr) throw new Error('bsvup calculated different address')
  }
  let bsvup = child_process.execFile(BSVUP, ['-p', 'Y', '-b', '-n', 'upload', '-s', subkey, '-f', mirror_path_new], { cwd: bsv_path })
  try {
    await new Promise((resolve, reject) => {
      const rl = readline.createInterface({input: bsvup.stdout})
      var success = true
      rl.on('line', (line) => {
        process.stderr.write(line + '\n')
        if (line.match('still need .* satoshis')) {
          success = false
          process.stderr.write('Send to ' + addr + '\n')
          rl.close()
        }
      })
      rl.on('close', ()=>success?resolve():reject())
    })
    // success
    rimraf.sync(mirror_path)
    fs.renameSync(mirror_path_new, mirror_path)
  } catch(e) {
    // failure
    process.stderr.write(e + '\n')
    rimraf.sync(mirror_path_new)
    process.exit(-1)
  }
}
